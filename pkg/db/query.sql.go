// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"encoding/json"
	"strings"
)

const countBooks = `-- name: CountBooks :one
SELECT COUNT(*) AS count FROM books
`

func (q *Queries) CountBooks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBooks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSeries = `-- name: CountSeries :one
SELECT COUNT(*) AS count FROM series
`

func (q *Queries) CountSeries(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSeries)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBook = `-- name: CreateBook :one
INSERT INTO books (book_id, title, description, series_name, series_number, asin, isbn10, isbn13, language, hardcover_id, hardcover_book_id, goodreads_id, google_id, data, is_missing)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, book_id, title, description, series_name, series_number, asin, isbn10, isbn13, language, hardcover_id, hardcover_book_id, goodreads_id, google_id, data, series_id, is_missing
`

type CreateBookParams struct {
	BookID          int64           `json:"book_id"`
	Title           string          `json:"title"`
	Description     string          `json:"description"`
	SeriesName      *string         `json:"series_name"`
	SeriesNumber    *float64        `json:"series_number"`
	Asin            *string         `json:"asin"`
	Isbn10          *string         `json:"isbn10"`
	Isbn13          *string         `json:"isbn13"`
	Language        *string         `json:"language"`
	HardcoverID     *string         `json:"hardcover_id"`
	HardcoverBookID *int64          `json:"hardcover_book_id"`
	GoodreadsID     *string         `json:"goodreads_id"`
	GoogleID        *string         `json:"google_id"`
	Data            json.RawMessage `json:"data"`
	IsMissing       *bool           `json:"is_missing"`
}

func (q *Queries) CreateBook(ctx context.Context, arg CreateBookParams) (Book, error) {
	row := q.db.QueryRowContext(ctx, createBook,
		arg.BookID,
		arg.Title,
		arg.Description,
		arg.SeriesName,
		arg.SeriesNumber,
		arg.Asin,
		arg.Isbn10,
		arg.Isbn13,
		arg.Language,
		arg.HardcoverID,
		arg.HardcoverBookID,
		arg.GoodreadsID,
		arg.GoogleID,
		arg.Data,
		arg.IsMissing,
	)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.Title,
		&i.Description,
		&i.SeriesName,
		&i.SeriesNumber,
		&i.Asin,
		&i.Isbn10,
		&i.Isbn13,
		&i.Language,
		&i.HardcoverID,
		&i.HardcoverBookID,
		&i.GoodreadsID,
		&i.GoogleID,
		&i.Data,
		&i.SeriesID,
		&i.IsMissing,
	)
	return i, err
}

const createMissingBook = `-- name: CreateMissingBook :one
INSERT INTO books (book_id, title, description, series_name, series_number, goodreads_id, series_id, is_missing)
VALUES (?, ?, ?, ?, ?, ?, ?, 1)
ON CONFLICT(book_id) DO UPDATE SET
    title = excluded.title,
    description = excluded.description,
    series_name = excluded.series_name,
    series_number = excluded.series_number,
    goodreads_id = excluded.goodreads_id,
    series_id = excluded.series_id,
    is_missing = 1
RETURNING id, book_id, title, description, series_name, series_number, asin, isbn10, isbn13, language, hardcover_id, hardcover_book_id, goodreads_id, google_id, data, series_id, is_missing
`

type CreateMissingBookParams struct {
	BookID       int64    `json:"book_id"`
	Title        string   `json:"title"`
	Description  string   `json:"description"`
	SeriesName   *string  `json:"series_name"`
	SeriesNumber *float64 `json:"series_number"`
	GoodreadsID  *string  `json:"goodreads_id"`
	SeriesID     *int64   `json:"series_id"`
}

func (q *Queries) CreateMissingBook(ctx context.Context, arg CreateMissingBookParams) (Book, error) {
	row := q.db.QueryRowContext(ctx, createMissingBook,
		arg.BookID,
		arg.Title,
		arg.Description,
		arg.SeriesName,
		arg.SeriesNumber,
		arg.GoodreadsID,
		arg.SeriesID,
	)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.Title,
		&i.Description,
		&i.SeriesName,
		&i.SeriesNumber,
		&i.Asin,
		&i.Isbn10,
		&i.Isbn13,
		&i.Language,
		&i.HardcoverID,
		&i.HardcoverBookID,
		&i.GoodreadsID,
		&i.GoogleID,
		&i.Data,
		&i.SeriesID,
		&i.IsMissing,
	)
	return i, err
}

const createSeries = `-- name: CreateSeries :one
INSERT INTO series (series_id, name, description, url, data)
VALUES (?, ?, ?, ?, ?)
RETURNING id, series_id, name, description, url, data
`

type CreateSeriesParams struct {
	SeriesID    int64           `json:"series_id"`
	Name        string          `json:"name"`
	Description *string         `json:"description"`
	Url         *string         `json:"url"`
	Data        json.RawMessage `json:"data"`
}

func (q *Queries) CreateSeries(ctx context.Context, arg CreateSeriesParams) (Series, error) {
	row := q.db.QueryRowContext(ctx, createSeries,
		arg.SeriesID,
		arg.Name,
		arg.Description,
		arg.Url,
		arg.Data,
	)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.Name,
		&i.Description,
		&i.Url,
		&i.Data,
	)
	return i, err
}

const getAuthorByName = `-- name: GetAuthorByName :one
SELECT id, name FROM authors
WHERE name = ? LIMIT 1
`

func (q *Queries) GetAuthorByName(ctx context.Context, name string) (Author, error) {
	row := q.db.QueryRowContext(ctx, getAuthorByName, name)
	var i Author
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getAuthorsForBook = `-- name: GetAuthorsForBook :many
SELECT a.id, a.name FROM authors a
JOIN book_authors ba ON a.id = ba.author_id
WHERE ba.book_id = ?
ORDER BY a.name ASC
`

func (q *Queries) GetAuthorsForBook(ctx context.Context, bookID int64) ([]Author, error) {
	rows, err := q.db.QueryContext(ctx, getAuthorsForBook, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Author
	for rows.Next() {
		var i Author
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuthorsForMultipleSeries = `-- name: GetAuthorsForMultipleSeries :many
SELECT sa.series_id, a.id, a.name FROM authors a
JOIN series_authors sa ON a.id = sa.author_id
WHERE sa.series_id IN (/*SLICE:series_ids*/?)
ORDER BY sa.series_id, a.name ASC
`

type GetAuthorsForMultipleSeriesRow struct {
	SeriesID int64  `json:"series_id"`
	ID       int64  `json:"id"`
	Name     string `json:"name"`
}

func (q *Queries) GetAuthorsForMultipleSeries(ctx context.Context, seriesIds []int64) ([]GetAuthorsForMultipleSeriesRow, error) {
	query := getAuthorsForMultipleSeries
	var queryParams []interface{}
	if len(seriesIds) > 0 {
		for _, v := range seriesIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:series_ids*/?", strings.Repeat(",?", len(seriesIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:series_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAuthorsForMultipleSeriesRow
	for rows.Next() {
		var i GetAuthorsForMultipleSeriesRow
		if err := rows.Scan(&i.SeriesID, &i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBook = `-- name: GetBook :one
SELECT id, book_id, title, description, series_name, series_number, asin, isbn10, isbn13, language, hardcover_id, hardcover_book_id, goodreads_id, google_id, data, series_id, is_missing FROM books
WHERE id = ? LIMIT 1
`

func (q *Queries) GetBook(ctx context.Context, id int64) (Book, error) {
	row := q.db.QueryRowContext(ctx, getBook, id)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.Title,
		&i.Description,
		&i.SeriesName,
		&i.SeriesNumber,
		&i.Asin,
		&i.Isbn10,
		&i.Isbn13,
		&i.Language,
		&i.HardcoverID,
		&i.HardcoverBookID,
		&i.GoodreadsID,
		&i.GoogleID,
		&i.Data,
		&i.SeriesID,
		&i.IsMissing,
	)
	return i, err
}

const getBookByBookID = `-- name: GetBookByBookID :one
SELECT id, book_id, title, description, series_name, series_number, asin, isbn10, isbn13, language, hardcover_id, hardcover_book_id, goodreads_id, google_id, data, series_id, is_missing FROM books
WHERE book_id = ? LIMIT 1
`

func (q *Queries) GetBookByBookID(ctx context.Context, bookID int64) (Book, error) {
	row := q.db.QueryRowContext(ctx, getBookByBookID, bookID)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.Title,
		&i.Description,
		&i.SeriesName,
		&i.SeriesNumber,
		&i.Asin,
		&i.Isbn10,
		&i.Isbn13,
		&i.Language,
		&i.HardcoverID,
		&i.HardcoverBookID,
		&i.GoodreadsID,
		&i.GoogleID,
		&i.Data,
		&i.SeriesID,
		&i.IsMissing,
	)
	return i, err
}

const getBooksBySeries = `-- name: GetBooksBySeries :many
SELECT id, book_id, title, description, series_name, series_number, asin, isbn10, isbn13, language, hardcover_id, hardcover_book_id, goodreads_id, google_id, data, series_id, is_missing FROM books
WHERE series_id = ?
ORDER BY series_number ASC
`

func (q *Queries) GetBooksBySeries(ctx context.Context, seriesID *int64) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, getBooksBySeries, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.BookID,
			&i.Title,
			&i.Description,
			&i.SeriesName,
			&i.SeriesNumber,
			&i.Asin,
			&i.Isbn10,
			&i.Isbn13,
			&i.Language,
			&i.HardcoverID,
			&i.HardcoverBookID,
			&i.GoodreadsID,
			&i.GoogleID,
			&i.Data,
			&i.SeriesID,
			&i.IsMissing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConfig = `-- name: GetConfig :one
SELECT value FROM configuration
WHERE key = ? LIMIT 1
`

func (q *Queries) GetConfig(ctx context.Context, key string) (string, error) {
	row := q.db.QueryRowContext(ctx, getConfig, key)
	var value string
	err := row.Scan(&value)
	return value, err
}

const getMultipleConfig = `-- name: GetMultipleConfig :many
SELECT key, value FROM configuration
WHERE key IN (?)
`

func (q *Queries) GetMultipleConfig(ctx context.Context, key string) ([]Configuration, error) {
	rows, err := q.db.QueryContext(ctx, getMultipleConfig, key)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Configuration
	for rows.Next() {
		var i Configuration
		if err := rows.Scan(&i.Key, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeries = `-- name: GetSeries :one
SELECT id, series_id, name, description, url, data FROM series
WHERE id = ? LIMIT 1
`

func (q *Queries) GetSeries(ctx context.Context, id int64) (Series, error) {
	row := q.db.QueryRowContext(ctx, getSeries, id)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.Name,
		&i.Description,
		&i.Url,
		&i.Data,
	)
	return i, err
}

const getSeriesAuthors = `-- name: GetSeriesAuthors :many
SELECT a.id, a.name FROM authors a
JOIN series_authors sa ON a.id = sa.author_id
WHERE sa.series_id = ?
ORDER BY a.name ASC
`

func (q *Queries) GetSeriesAuthors(ctx context.Context, seriesID int64) ([]Author, error) {
	rows, err := q.db.QueryContext(ctx, getSeriesAuthors, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Author
	for rows.Next() {
		var i Author
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeriesByGoodreadsID = `-- name: GetSeriesByGoodreadsID :one
SELECT id, series_id, name, description, url, data FROM series
WHERE series_id = ? LIMIT 1
`

func (q *Queries) GetSeriesByGoodreadsID(ctx context.Context, seriesID int64) (Series, error) {
	row := q.db.QueryRowContext(ctx, getSeriesByGoodreadsID, seriesID)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.Name,
		&i.Description,
		&i.Url,
		&i.Data,
	)
	return i, err
}

const getSeriesBySeriesID = `-- name: GetSeriesBySeriesID :one
SELECT id, series_id, name, description, url, data FROM series
WHERE series_id = ? LIMIT 1
`

func (q *Queries) GetSeriesBySeriesID(ctx context.Context, seriesID int64) (Series, error) {
	row := q.db.QueryRowContext(ctx, getSeriesBySeriesID, seriesID)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.Name,
		&i.Description,
		&i.Url,
		&i.Data,
	)
	return i, err
}

const linkBookAuthor = `-- name: LinkBookAuthor :exec
INSERT INTO book_authors (book_id, author_id)
VALUES (?, ?)
ON CONFLICT (book_id, author_id) DO NOTHING
`

type LinkBookAuthorParams struct {
	BookID   int64 `json:"book_id"`
	AuthorID int64 `json:"author_id"`
}

func (q *Queries) LinkBookAuthor(ctx context.Context, arg LinkBookAuthorParams) error {
	_, err := q.db.ExecContext(ctx, linkBookAuthor, arg.BookID, arg.AuthorID)
	return err
}

const linkSeriesAuthor = `-- name: LinkSeriesAuthor :exec
INSERT INTO series_authors (series_id, author_id)
VALUES (?, ?)
ON CONFLICT (series_id, author_id) DO NOTHING
`

type LinkSeriesAuthorParams struct {
	SeriesID int64 `json:"series_id"`
	AuthorID int64 `json:"author_id"`
}

func (q *Queries) LinkSeriesAuthor(ctx context.Context, arg LinkSeriesAuthorParams) error {
	_, err := q.db.ExecContext(ctx, linkSeriesAuthor, arg.SeriesID, arg.AuthorID)
	return err
}

const listBooks = `-- name: ListBooks :many
SELECT id, book_id, title, description, series_name, series_number, asin, isbn10, isbn13, language, hardcover_id, hardcover_book_id, goodreads_id, google_id, data, series_id, is_missing FROM books
ORDER BY title ASC
LIMIT ? OFFSET ?
`

type ListBooksParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListBooks(ctx context.Context, arg ListBooksParams) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, listBooks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.BookID,
			&i.Title,
			&i.Description,
			&i.SeriesName,
			&i.SeriesNumber,
			&i.Asin,
			&i.Isbn10,
			&i.Isbn13,
			&i.Language,
			&i.HardcoverID,
			&i.HardcoverBookID,
			&i.GoodreadsID,
			&i.GoogleID,
			&i.Data,
			&i.SeriesID,
			&i.IsMissing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeries = `-- name: ListSeries :many
SELECT id, series_id, name, description, url, data FROM series
ORDER BY id ASC
LIMIT ? OFFSET ?
`

type ListSeriesParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListSeries(ctx context.Context, arg ListSeriesParams) ([]Series, error) {
	rows, err := q.db.QueryContext(ctx, listSeries, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Series
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.Name,
			&i.Description,
			&i.Url,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeriesWithBookStats = `-- name: ListSeriesWithBookStats :many
SELECT 
    s.id,
    s.series_id,
    s.name,
    s.description,
    s.url,
    s.data,
    COUNT(b.id) as total_books,
    CAST(SUM(CASE WHEN b.is_missing = 1 THEN 1 ELSE 0 END) AS INTEGER) as missing_books
FROM series s
LEFT JOIN books b ON s.id = b.series_id
GROUP BY s.id, s.series_id, s.name, s.description, s.url, s.data
ORDER BY s.id ASC
LIMIT ? OFFSET ?
`

type ListSeriesWithBookStatsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type ListSeriesWithBookStatsRow struct {
	ID           int64           `json:"id"`
	SeriesID     int64           `json:"series_id"`
	Name         string          `json:"name"`
	Description  *string         `json:"description"`
	Url          *string         `json:"url"`
	Data         json.RawMessage `json:"data"`
	TotalBooks   int64           `json:"total_books"`
	MissingBooks int64           `json:"missing_books"`
}

func (q *Queries) ListSeriesWithBookStats(ctx context.Context, arg ListSeriesWithBookStatsParams) ([]ListSeriesWithBookStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, listSeriesWithBookStats, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSeriesWithBookStatsRow
	for rows.Next() {
		var i ListSeriesWithBookStatsRow
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.Name,
			&i.Description,
			&i.Url,
			&i.Data,
			&i.TotalBooks,
			&i.MissingBooks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setConfig = `-- name: SetConfig :exec
INSERT INTO configuration (key, value)
VALUES (?, ?)
ON CONFLICT(key) DO UPDATE SET value = excluded.value
`

type SetConfigParams struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (q *Queries) SetConfig(ctx context.Context, arg SetConfigParams) error {
	_, err := q.db.ExecContext(ctx, setConfig, arg.Key, arg.Value)
	return err
}

const updateBookSeries = `-- name: UpdateBookSeries :exec
UPDATE books
SET series_id = ?
WHERE id = ?
`

type UpdateBookSeriesParams struct {
	SeriesID *int64 `json:"series_id"`
	ID       int64  `json:"id"`
}

func (q *Queries) UpdateBookSeries(ctx context.Context, arg UpdateBookSeriesParams) error {
	_, err := q.db.ExecContext(ctx, updateBookSeries, arg.SeriesID, arg.ID)
	return err
}

const upsertAuthor = `-- name: UpsertAuthor :one
INSERT INTO authors (name)
VALUES (?)
ON CONFLICT(name) DO UPDATE SET name=excluded.name
RETURNING id, name
`

func (q *Queries) UpsertAuthor(ctx context.Context, name string) (Author, error) {
	row := q.db.QueryRowContext(ctx, upsertAuthor, name)
	var i Author
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const upsertBook = `-- name: UpsertBook :one
INSERT INTO books (book_id, title, description, series_name, series_number, asin, isbn10, isbn13, language, hardcover_id, hardcover_book_id, goodreads_id, google_id, data, is_missing)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(book_id) DO UPDATE SET
    title = excluded.title,
    description = excluded.description,
    series_name = excluded.series_name,
    series_number = excluded.series_number,
    asin = excluded.asin,
    isbn10 = excluded.isbn10,
    isbn13 = excluded.isbn13,
    language = excluded.language,
    hardcover_id = excluded.hardcover_id,
    hardcover_book_id = excluded.hardcover_book_id,
    goodreads_id = excluded.goodreads_id,
    google_id = excluded.google_id,
    data = excluded.data,
    is_missing = excluded.is_missing
RETURNING id, book_id, title, description, series_name, series_number, asin, isbn10, isbn13, language, hardcover_id, hardcover_book_id, goodreads_id, google_id, data, series_id, is_missing
`

type UpsertBookParams struct {
	BookID          int64           `json:"book_id"`
	Title           string          `json:"title"`
	Description     string          `json:"description"`
	SeriesName      *string         `json:"series_name"`
	SeriesNumber    *float64        `json:"series_number"`
	Asin            *string         `json:"asin"`
	Isbn10          *string         `json:"isbn10"`
	Isbn13          *string         `json:"isbn13"`
	Language        *string         `json:"language"`
	HardcoverID     *string         `json:"hardcover_id"`
	HardcoverBookID *int64          `json:"hardcover_book_id"`
	GoodreadsID     *string         `json:"goodreads_id"`
	GoogleID        *string         `json:"google_id"`
	Data            json.RawMessage `json:"data"`
	IsMissing       *bool           `json:"is_missing"`
}

func (q *Queries) UpsertBook(ctx context.Context, arg UpsertBookParams) (Book, error) {
	row := q.db.QueryRowContext(ctx, upsertBook,
		arg.BookID,
		arg.Title,
		arg.Description,
		arg.SeriesName,
		arg.SeriesNumber,
		arg.Asin,
		arg.Isbn10,
		arg.Isbn13,
		arg.Language,
		arg.HardcoverID,
		arg.HardcoverBookID,
		arg.GoodreadsID,
		arg.GoogleID,
		arg.Data,
		arg.IsMissing,
	)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.Title,
		&i.Description,
		&i.SeriesName,
		&i.SeriesNumber,
		&i.Asin,
		&i.Isbn10,
		&i.Isbn13,
		&i.Language,
		&i.HardcoverID,
		&i.HardcoverBookID,
		&i.GoodreadsID,
		&i.GoogleID,
		&i.Data,
		&i.SeriesID,
		&i.IsMissing,
	)
	return i, err
}

const upsertSeries = `-- name: UpsertSeries :one
INSERT INTO series (series_id, name, description, url, data)
VALUES (?, ?, ?, ?, ?)
ON CONFLICT(series_id) DO UPDATE SET
    name = excluded.name,
    description = excluded.description,
    url = excluded.url,
    data = excluded.data
RETURNING id, series_id, name, description, url, data
`

type UpsertSeriesParams struct {
	SeriesID    int64           `json:"series_id"`
	Name        string          `json:"name"`
	Description *string         `json:"description"`
	Url         *string         `json:"url"`
	Data        json.RawMessage `json:"data"`
}

func (q *Queries) UpsertSeries(ctx context.Context, arg UpsertSeriesParams) (Series, error) {
	row := q.db.QueryRowContext(ctx, upsertSeries,
		arg.SeriesID,
		arg.Name,
		arg.Description,
		arg.Url,
		arg.Data,
	)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.Name,
		&i.Description,
		&i.Url,
		&i.Data,
	)
	return i, err
}
