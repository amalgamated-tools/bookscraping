// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"
)

const countBooks = `-- name: CountBooks :one
SELECT COUNT(*) AS count FROM books
`

func (q *Queries) CountBooks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBooks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSeries = `-- name: CountSeries :one
SELECT COUNT(*) AS count FROM series
`

func (q *Queries) CountSeries(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSeries)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBook = `-- name: CreateBook :one
INSERT INTO books (book_id, title, description, series_name, series_number, asin, isbn10, isbn13, language, hardcover_id, hardcover_book_id, goodreads_id, google_id, data)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, book_id, title, description, series_name, series_number, asin, isbn10, isbn13, language, hardcover_id, hardcover_book_id, goodreads_id, google_id, data
`

type CreateBookParams struct {
	BookID          int64       `json:"book_id"`
	Title           string      `json:"title"`
	Description     string      `json:"description"`
	SeriesName      *string     `json:"series_name"`
	SeriesNumber    *int64      `json:"series_number"`
	Asin            *string     `json:"asin"`
	Isbn10          *string     `json:"isbn10"`
	Isbn13          *string     `json:"isbn13"`
	Language        *string     `json:"language"`
	HardcoverID     *string     `json:"hardcover_id"`
	HardcoverBookID *int64      `json:"hardcover_book_id"`
	GoodreadsID     *string     `json:"goodreads_id"`
	GoogleID        *string     `json:"google_id"`
	Data            interface{} `json:"data"`
}

func (q *Queries) CreateBook(ctx context.Context, arg CreateBookParams) (Book, error) {
	row := q.db.QueryRowContext(ctx, createBook,
		arg.BookID,
		arg.Title,
		arg.Description,
		arg.SeriesName,
		arg.SeriesNumber,
		arg.Asin,
		arg.Isbn10,
		arg.Isbn13,
		arg.Language,
		arg.HardcoverID,
		arg.HardcoverBookID,
		arg.GoodreadsID,
		arg.GoogleID,
		arg.Data,
	)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.Title,
		&i.Description,
		&i.SeriesName,
		&i.SeriesNumber,
		&i.Asin,
		&i.Isbn10,
		&i.Isbn13,
		&i.Language,
		&i.HardcoverID,
		&i.HardcoverBookID,
		&i.GoodreadsID,
		&i.GoogleID,
		&i.Data,
	)
	return i, err
}

const createSeries = `-- name: CreateSeries :one
INSERT INTO series (series_id, name, description, url, data)
VALUES (?, ?, ?, ?, ?)
RETURNING id, series_id, name, description, url, data
`

type CreateSeriesParams struct {
	SeriesID    int64       `json:"series_id"`
	Name        string      `json:"name"`
	Description *string     `json:"description"`
	Url         *string     `json:"url"`
	Data        interface{} `json:"data"`
}

func (q *Queries) CreateSeries(ctx context.Context, arg CreateSeriesParams) (Series, error) {
	row := q.db.QueryRowContext(ctx, createSeries,
		arg.SeriesID,
		arg.Name,
		arg.Description,
		arg.Url,
		arg.Data,
	)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.Name,
		&i.Description,
		&i.Url,
		&i.Data,
	)
	return i, err
}

const getBook = `-- name: GetBook :one
SELECT id, book_id, title, description, series_name, series_number, asin, isbn10, isbn13, language, hardcover_id, hardcover_book_id, goodreads_id, google_id, data FROM books
WHERE id = ? LIMIT 1
`

func (q *Queries) GetBook(ctx context.Context, id int64) (Book, error) {
	row := q.db.QueryRowContext(ctx, getBook, id)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.Title,
		&i.Description,
		&i.SeriesName,
		&i.SeriesNumber,
		&i.Asin,
		&i.Isbn10,
		&i.Isbn13,
		&i.Language,
		&i.HardcoverID,
		&i.HardcoverBookID,
		&i.GoodreadsID,
		&i.GoogleID,
		&i.Data,
	)
	return i, err
}

const getBookByBookID = `-- name: GetBookByBookID :one
SELECT id, book_id, title, description, series_name, series_number, asin, isbn10, isbn13, language, hardcover_id, hardcover_book_id, goodreads_id, google_id, data FROM books
WHERE book_id = ? LIMIT 1
`

func (q *Queries) GetBookByBookID(ctx context.Context, bookID int64) (Book, error) {
	row := q.db.QueryRowContext(ctx, getBookByBookID, bookID)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.Title,
		&i.Description,
		&i.SeriesName,
		&i.SeriesNumber,
		&i.Asin,
		&i.Isbn10,
		&i.Isbn13,
		&i.Language,
		&i.HardcoverID,
		&i.HardcoverBookID,
		&i.GoodreadsID,
		&i.GoogleID,
		&i.Data,
	)
	return i, err
}

const getSeries = `-- name: GetSeries :one
SELECT id, series_id, name, description, url, data FROM series
WHERE id = ? LIMIT 1
`

func (q *Queries) GetSeries(ctx context.Context, id int64) (Series, error) {
	row := q.db.QueryRowContext(ctx, getSeries, id)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.Name,
		&i.Description,
		&i.Url,
		&i.Data,
	)
	return i, err
}

const getSeriesBySeriesID = `-- name: GetSeriesBySeriesID :one
SELECT id, series_id, name, description, url, data FROM series
WHERE series_id = ? LIMIT 1
`

func (q *Queries) GetSeriesBySeriesID(ctx context.Context, seriesID int64) (Series, error) {
	row := q.db.QueryRowContext(ctx, getSeriesBySeriesID, seriesID)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.Name,
		&i.Description,
		&i.Url,
		&i.Data,
	)
	return i, err
}

const listBooks = `-- name: ListBooks :many
SELECT id, book_id, title, description, series_name, series_number, asin, isbn10, isbn13, language, hardcover_id, hardcover_book_id, goodreads_id, google_id, data FROM books
ORDER BY id ASC
LIMIT ? OFFSET ?
`

type ListBooksParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListBooks(ctx context.Context, arg ListBooksParams) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, listBooks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.BookID,
			&i.Title,
			&i.Description,
			&i.SeriesName,
			&i.SeriesNumber,
			&i.Asin,
			&i.Isbn10,
			&i.Isbn13,
			&i.Language,
			&i.HardcoverID,
			&i.HardcoverBookID,
			&i.GoodreadsID,
			&i.GoogleID,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeries = `-- name: ListSeries :many
SELECT id, series_id, name, description, url, data FROM series
ORDER BY id ASC
LIMIT ? OFFSET ?
`

type ListSeriesParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListSeries(ctx context.Context, arg ListSeriesParams) ([]Series, error) {
	rows, err := q.db.QueryContext(ctx, listSeries, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Series
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.Name,
			&i.Description,
			&i.Url,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
