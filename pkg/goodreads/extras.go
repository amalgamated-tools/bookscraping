package goodreads

// // GetQuotes fetches quotes for a book
// func (c *Client) GetQuotes(bookID string, page int) ([]Quote, error) {
// 	url := fmt.Sprintf("%s/quotes/book/%s?page=%d", c.baseURL, bookID, page)
// 	doc, err := c.parseHTML(url)
// 	if err != nil {
// 		return nil, fmt.Errorf("fetching quotes: %w", err)
// 	}

// 	var quotes []Quote

// }	return list, nil	})		}			list.Books = append(list.Books, book)		if book.Title != "" {				book.Rating = parseFloat(ratingStr)		ratingStr := s.Find("span.minirating").Text()		// Rating				book.CoverImageURL = imgSrc		imgSrc, _ := s.Find("img.bookCover").Attr("src")		// Cover				}			})				Name: strings.TrimSpace(authorLink.Text()),			book.Authors = append(book.Authors, Author{		if authorLink.Length() > 0 {		authorLink := s.Find("a.authorName")		// Author				}			}				book.ID = matches[1]			if matches := re.FindStringSubmatch(bookURL); len(matches) > 1 {			re := regexp.MustCompile(`/book/show/(\d+)`)						book.URL = c.baseURL + bookURL		if bookURL != "" {		bookURL, _ := titleLink.Attr("href")		book.Title = strings.TrimSpace(titleLink.Text())		titleLink := s.Find("a.bookTitle")		// Title				book := Book{}	doc.Find("tr[itemtype='http://schema.org/Book']").Each(func(i int, s *goquery.Selection) {	// Books	}		list.VoterCount = parseCount(matches[1])	if matches := re.FindStringSubmatch(statsText); len(matches) > 1 {	re = regexp.MustCompile(`(\d+)\s+voters`)		}		list.BookCount = parseCount(matches[1])	if matches := re.FindStringSubmatch(statsText); len(matches) > 1 {	re := regexp.MustCompile(`(\d+)\s+books`)	statsText := doc.Find("div.smallText").Text()	// Stats	list.Description = strings.TrimSpace(doc.Find("div.mediumText").First().Text())	// Description		list.Title = strings.TrimSpace(doc.Find("h1.gr-h1").Text())	// List title	}		URL: url,		ID:  listID,	list := &List{	}		return nil, fmt.Errorf("fetching list: %w", err)	if err != nil {	doc, err := c.parseHTML(url)	url := fmt.Sprintf("%s/list/show/%s", c.baseURL, listID)func (c *Client) GetList(listID string) (*List, error) {// GetList fetches a Goodreads list}	return series, nil	series.BookCount = len(series.Books)	})		}			})				Position: position,				Book:     book,			series.Books = append(series.Books, SeriesBook{		if book.Title != "" {				book.Rating = parseFloat(ratingStr)		ratingStr := s.Find("span[class*='minirating']").Text()		// Rating				book.CoverImageURL = imgSrc		imgSrc, _ := s.Find("img").Attr("src")		// Cover				}			})				Name: strings.TrimSpace(authorLink.Text()),			book.Authors = append(book.Authors, Author{		if authorLink.Length() > 0 {		authorLink := s.Find("a[class*='authorName']")		// Author				position := strings.TrimSpace(s.Find("span[class*='position']").Text())		// Position in series				}			}				book.ID = matches[1]			if matches := re.FindStringSubmatch(bookURL); len(matches) > 1 {			re := regexp.MustCompile(`/book/show/(\d+)`)						book.URL = c.baseURL + bookURL		if bookURL != "" {		bookURL, _ := titleLink.Attr("href")		book.Title = strings.TrimSpace(titleLink.Text())		titleLink := s.Find("a[class*='gr-h3']")		// Title				book := Book{}	doc.Find("div[itemtype='http://schema.org/Book']").Each(func(i int, s *goquery.Selection) {	// Books in series	series.Description = strings.TrimSpace(doc.Find("div.responsiveSeriesHeader__description").Text())	// Description		series.Name = strings.TrimSpace(doc.Find("h1").First().Text())	// Series name	}		URL: url,		ID:  seriesID,	series := &Series{	}		return nil, fmt.Errorf("fetching series: %w", err)	if err != nil {	doc, err := c.parseHTML(url)	url := fmt.Sprintf("%s/series/%s", c.baseURL, seriesID)func (c *Client) GetSeries(seriesID string) (*Series, error) {// GetSeries fetches information about a series}	return quotes, nil	})		}			quotes = append(quotes, quote)		if quote.Text != "" {				quote.Likes = parseCount(likesText)		likesText := s.Find("a.smallText").Text()		// Likes				})			}				quote.Tags = append(quote.Tags, tagText)			if tagText != "" {			tagText := strings.TrimSpace(tag.Text())		s.Find("a.actionLinkLite.bookPageGenreLink").Each(func(j int, tag *goquery.Selection) {		// Tags				}			}				quote.BookID = matches[1]			if matches := re.FindStringSubmatch(bookURL); len(matches) > 1 {			re := regexp.MustCompile(`/work/quotes/(\d+)`)		if bookURL != "" {		bookURL, _ := bookLink.Attr("href")		quote.BookName = strings.TrimSpace(bookLink.Text())		bookLink := s.Find("a.authorOrTitle")		// Book name				quote.Author = strings.TrimSpace(authorLink.Text())		authorLink := s.Find("span.authorOrTitle")		// Author and book info				quote.Text = strings.Join(cleanLines, " ")		}			}				cleanLines = append(cleanLines, line)			if line != "" && !strings.HasPrefix(line, "â€•") && !strings.HasPrefix(line, "tags:") {			line = strings.TrimSpace(line)		for _, line := range lines {		var cleanLines []string		lines := strings.Split(quoteText, "\n")		// Clean up the quote text		quoteText := s.Find("div.quoteText").Text()		// Quote text				}			}				quote.ID = matches[1]			if matches := re.FindStringSubmatch(quoteIDAttr); len(matches) > 1 {			re := regexp.MustCompile(`quote_(\d+)`)		if quoteIDAttr != "" {		quoteIDAttr, _ := s.Attr("id")		// Quote ID				quote := Quote{}	doc.Find("div.quote").Each(func(i int, s *goquery.Selection) {
